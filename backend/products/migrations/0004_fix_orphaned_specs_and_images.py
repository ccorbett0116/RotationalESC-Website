# Generated by custom data migration
from django.db import migrations
import uuid


def fix_orphaned_data(apps, schema_editor):
    """
    Create fake products for orphaned specifications and images
    """
    Product = apps.get_model('products', 'Product')
    ProductSpecification = apps.get_model('products', 'ProductSpecification')
    ProductImage = apps.get_model('products', 'ProductImage')
    Category = apps.get_model('products', 'Category')
    
    # Get all orphaned specifications (those with non-existent product_ids)
    orphaned_spec_product_ids = set()
    for spec in ProductSpecification.objects.all():
        try:
            Product.objects.get(id=spec.product_id)
        except Product.DoesNotExist:
            orphaned_spec_product_ids.add(spec.product_id)
    
    # Get all orphaned images (those with non-existent product_ids)
    orphaned_image_product_ids = set()
    for image in ProductImage.objects.all():
        try:
            Product.objects.get(id=image.product_id)
        except Product.DoesNotExist:
            orphaned_image_product_ids.add(image.product_id)
    
    # Combine all orphaned product IDs
    all_orphaned_ids = orphaned_spec_product_ids.union(orphaned_image_product_ids)
    
    if not all_orphaned_ids:
        return  # No orphaned data, nothing to fix
    
    # Ensure we have a default category
    default_category, created = Category.objects.get_or_create(
        name="Legacy",
        defaults={
            'description': 'Legacy products created during migration'
        }
    )
    
    # Create fake products for each orphaned ID
    for old_product_id in all_orphaned_ids:
        # Create a product with the old ID as UUID if possible, otherwise generate new UUID
        try:
            # Try to use the old ID as UUID (this will work if it's already a valid UUID)
            if isinstance(old_product_id, str):
                product_uuid = uuid.UUID(old_product_id)
            else:
                # If it's an integer, create a deterministic UUID based on it
                product_uuid = uuid.UUID(f'00000000-0000-0000-0000-{old_product_id:012d}')
        except (ValueError, TypeError):
            # If we can't create a deterministic UUID, generate a random one
            product_uuid = uuid.uuid4()
        
        # Check if product with this UUID already exists
        if not Product.objects.filter(id=product_uuid).exists():
            Product.objects.create(
                id=product_uuid,
                name=f"Legacy Product {old_product_id}",
                description="This is a legacy product created during migration to fix orphaned data.",
                price=0.00,
                category=default_category,
                in_stock=False,
                tags="legacy,migration"
            )
        
        # Update orphaned specifications to point to the new product
        ProductSpecification.objects.filter(product_id=old_product_id).update(product_id=product_uuid)
        
        # Update orphaned images to point to the new product
        ProductImage.objects.filter(product_id=old_product_id).update(product_id=product_uuid)


def reverse_fix_orphaned_data(apps, schema_editor):
    """
    Remove fake products created during migration
    """
    Product = apps.get_model('products', 'Product')
    Category = apps.get_model('products', 'Category')
    
    # Remove legacy products
    Product.objects.filter(tags__contains="legacy,migration").delete()
    
    # Remove legacy category if it has no products
    try:
        legacy_category = Category.objects.get(name="Legacy")
        if not legacy_category.products.exists():
            legacy_category.delete()
    except Category.DoesNotExist:
        pass


class Migration(migrations.Migration):

    dependencies = [
        ('products', '0003_section_manufacturer'),
    ]

    operations = [
        migrations.RunPython(
            fix_orphaned_data,
            reverse_fix_orphaned_data
        ),
    ]
